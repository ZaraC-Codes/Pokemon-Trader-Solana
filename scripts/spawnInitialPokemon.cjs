/**
 * Spawn Initial Pokemon Script
 * @author Z33Fi ("Z33Fi Made It")
 *
 * Network: ApeChain Mainnet (Chain ID: 33139)
 *
 * This script spawns 3 initial Pokemon using forceSpawnPokemon().
 * The pokemon ID is auto-generated by the contract.
 *
 * Usage:
 *   npx hardhat run scripts/spawnInitialPokemon.cjs --network apechain
 *
 * Prerequisites:
 *   - DEPLOYER_PRIVATE_KEY in .env (must be contract owner)
 *   - Contract deployed at POKEBALL_GAME_ADDRESS
 */

const { ethers } = require("hardhat");

// ============ Configuration ============

// PokeballGame proxy address (deployed on ApeChain)
const POKEBALL_GAME_ADDRESS = "0xB6e86aF8a85555c6Ac2D812c8B8BE8a60C1C432f";

// Initial Pokemon spawn positions
// Format: { slot, x, y }
// slot: 0-2 (MAX_ACTIVE_POKEMON is 3)
// x, y: 0-999 coordinates
const INITIAL_SPAWNS = [
  { slot: 0, x: 100, y: 200 },
  { slot: 1, x: 500, y: 300 },
  { slot: 2, x: 800, y: 700 },
];

// Minimal ABI for forceSpawnPokemon and reading state
const POKEBALL_GAME_ABI = [
  "function forceSpawnPokemon(uint8 slot, uint256 posX, uint256 posY) external",
  "function getAllActivePokemons() external view returns (tuple(uint256 id, uint256 positionX, uint256 positionY, uint8 throwAttempts, bool isActive, uint256 spawnTime)[3])",
  "function owner() external view returns (address)",
  "function nextPokemonId() external view returns (uint256)",
  "event PokemonSpawned(uint256 indexed pokemonId, uint256 positionX, uint256 positionY, uint8 slot)",
];

// ============ Main Function ============

async function main() {
  console.log("============================================");
  console.log("  Pokemon Trader - Spawn Initial Pokemon");
  console.log("  Network: ApeChain Mainnet (33139)");
  console.log("============================================\n");

  // Get signer
  const [signer] = await ethers.getSigners();
  console.log("Signer address:", signer.address);

  const balance = await ethers.provider.getBalance(signer.address);
  // ethers v6 uses ethers.formatEther, v5 uses ethers.utils.formatEther
  const formatEther = ethers.formatEther || ethers.utils.formatEther;
  console.log("Signer balance:", formatEther(balance), "APE\n");

  // Connect to contract
  const pokeballGame = new ethers.Contract(
    POKEBALL_GAME_ADDRESS,
    POKEBALL_GAME_ABI,
    signer
  );

  // Verify ownership
  const owner = await pokeballGame.owner();
  console.log("Contract owner:", owner);

  if (signer.address.toLowerCase() !== owner.toLowerCase()) {
    console.error("\n❌ ERROR: Signer is not the contract owner!");
    console.error("   Signer:", signer.address);
    console.error("   Owner: ", owner);
    console.error("\nOnly the owner can call forceSpawnPokemon().");
    process.exit(1);
  }

  console.log("✅ Ownership verified\n");

  // Check current Pokemon state before spawning
  console.log("--- Current Pokemon State ---\n");
  const beforePokemons = await pokeballGame.getAllActivePokemons();
  const activeCount = beforePokemons.filter((p) => p.isActive).length;
  console.log(`Active Pokemon: ${activeCount}/3`);

  if (activeCount > 0) {
    console.log("\nExisting Pokemon:");
    beforePokemons.forEach((p, i) => {
      if (p.isActive) {
        console.log(
          `  Slot ${i}: ID=${p.id.toString()}, pos=(${p.positionX.toString()}, ${p.positionY.toString()})`
        );
      }
    });
  }

  // Spawn Pokemon
  console.log("\n--- Spawning Pokemon ---\n");

  const txHashes = [];

  for (const spawn of INITIAL_SPAWNS) {
    // Check if slot is already occupied
    if (beforePokemons[spawn.slot]?.isActive) {
      console.log(
        `⚠️  Slot ${spawn.slot} already occupied, skipping...`
      );
      continue;
    }

    console.log(
      `Spawning Pokemon at slot ${spawn.slot} (x=${spawn.x}, y=${spawn.y})...`
    );

    try {
      const tx = await pokeballGame.forceSpawnPokemon(
        spawn.slot,
        spawn.x,
        spawn.y
      );

      console.log(`  TX submitted: ${tx.hash}`);
      console.log("  Waiting for confirmation...");

      const receipt = await tx.wait();
      console.log(`  ✅ Confirmed in block ${receipt.blockNumber}`);

      // Parse PokemonSpawned event
      const spawnEvent = receipt.logs.find((log) => {
        try {
          const parsed = pokeballGame.interface.parseLog({
            topics: log.topics,
            data: log.data,
          });
          return parsed?.name === "PokemonSpawned";
        } catch {
          return false;
        }
      });

      if (spawnEvent) {
        const parsed = pokeballGame.interface.parseLog({
          topics: spawnEvent.topics,
          data: spawnEvent.data,
        });
        console.log(`  Pokemon ID: ${parsed.args.pokemonId.toString()}`);
      }

      txHashes.push(tx.hash);
      console.log("");
    } catch (error) {
      console.error(`  ❌ Failed to spawn at slot ${spawn.slot}:`, error.message);
      console.log("");
    }
  }

  // Verify final state
  console.log("--- Final Pokemon State ---\n");
  const afterPokemons = await pokeballGame.getAllActivePokemons();
  const finalActiveCount = afterPokemons.filter((p) => p.isActive).length;

  console.log(`Active Pokemon: ${finalActiveCount}/3\n`);

  afterPokemons.forEach((p, i) => {
    if (p.isActive) {
      console.log(
        `  Slot ${i}: ID=${p.id.toString()}, pos=(${p.positionX.toString()}, ${p.positionY.toString()}), attempts=${p.throwAttempts.toString()}`
      );
    } else {
      console.log(`  Slot ${i}: (empty)`);
    }
  });

  // Summary
  console.log("\n============================================");
  console.log("  Spawn Summary");
  console.log("============================================\n");

  if (txHashes.length > 0) {
    console.log(`✅ Successfully spawned ${txHashes.length} Pokemon\n`);
    console.log("Transaction hashes:");
    txHashes.forEach((hash, i) => {
      console.log(`  ${i + 1}. ${hash}`);
    });
    console.log(`\nView on Apescan:`);
    txHashes.forEach((hash) => {
      console.log(`  https://apescan.io/tx/${hash}`);
    });
  } else {
    console.log("No new Pokemon spawned (slots may already be occupied).");
  }

  console.log("\n============================================");
  console.log("  Done!");
  console.log("============================================\n");
}

// Execute
main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error("\n❌ Script failed:");
    console.error(error);
    process.exit(1);
  });
